use std::{
    env,
    fs::File,
    io::{prelude::*, stdin, stdout, BufReader},
    process::exit,
};

/// all the possible rubber ducky commands
/// based on https://docs.hak5.org/usb-rubber-ducky-1/the-ducky-script-language/ducky-script-quick-reference
#[derive(Debug)]
enum DuckyCommand {
    Comment(String),
    Delay(u64),
    String(String),
    Gui(char),
    Modifier(String, char),
    Menu,
    DownArrow,
    LeftArrow,
    RightArrow,
    UpArrow,
    Extended(String),
    FunctionKey(u8),
}

const TEMPLATE: &str = r#"
// Generated by ducky2ino
#include "DigiKeyboard.h"
void setup() {
    pinMode(1, OUTPUT); // setup led
    DigiKeyboard.update();
    DigiKeyboard.sendKeyStroke(0);

    $CODE$

    digitalWrite(1, HIGH); // turn on the led on finish
}
void loop(){}
"#;

fn main() {
    let mut args = env::args().skip(1);
    let input = args.next().unwrap_or("-".to_string());
    let output = args.next().unwrap_or("-".to_string());

    let reader: Box<dyn BufRead> = if input == "-" {
        Box::new(BufReader::new(stdin()))
    } else {
        Box::new(BufReader::new(match File::open(&input) {
            Ok(f) => f,
            Err(_) => {
                eprintln!("Could not open input file {}", &input);
                exit(1);
            }
        }))
    };
    let mut writer: Box<dyn Write> = if output == "-" {
        Box::new(stdout())
    } else {
        Box::new(match File::create(&output) {
            Ok(f) => f,
            Err(_) => {
                eprintln!("Could not open output file {}", &output);
                exit(1);
            }
        })
    };

    let mut res = String::new();
    let mut tree: Vec<DuckyCommand> = Vec::new();
    for (index, line) in reader.lines().enumerate() {
        if let Ok(line) = line {
            res.push_str(&line);
            res.push('\n');

            let mut words = line.split_whitespace();
            let command = match words.next() {
                Some(s) => s,
                None => continue,
            };
            let args: String = words.collect::<Vec<_>>().join(" ");

            tree.push(match command {
                "REM" => DuckyCommand::Comment(args),
                "DELAY" => DuckyCommand::Delay(
                    args.parse()
                        .expect(&format!("Could not parse delay: line {}", index + 1)),
                ),
                "STRING" => DuckyCommand::String(args.replace('\\', r#"\\"#).replace('"', r#"\""#)), // escape "quotes" and \backslashes
                "GUI" | "WINDOWS" => DuckyCommand::Gui(args.chars().next().unwrap()),
                "SHIFT" | "ALT" | "CTRL" => {
                    DuckyCommand::Modifier(command.to_string(), args.chars().next().unwrap())
                }
                "MENU" => DuckyCommand::Menu,
                "DOWNARROW" | "DOWN" => DuckyCommand::DownArrow,
                "LEFTARROW" | "LEFT" => DuckyCommand::LeftArrow,
                "RIGHTARROW" | "RIGHT" => DuckyCommand::RightArrow,
                "UPARROW" | "UP" => DuckyCommand::UpArrow,
                "BREAK" | "PAUSE" | "CAPSLOCK" | "DELETE" | "END" | "ESC" | "ESCAPE" | "HOME"
                | "INSERT" | "NUMLOCK" | "PAGEUP" | "PAGEDOWN" | "PRINTSCREEN" | "SCROLLOCK"
                | "SPACE" | "TAB" | "ENTER" => DuckyCommand::Extended(
                    (match command {
                        "PAUSE" => "BREAK",
                        "ESCAPE" => "ESC",
                        "SCROLLLOCK" => "SCROLLOCK",
                        _ => command,
                    })
                    .to_string(),
                ),
                "F1" | "F2" | "F3" | "F4" | "F5" | "F6" | "F7" | "F8" | "F9" | "F10" | "F11"
                | "F12" => DuckyCommand::FunctionKey(command[1..].parse().unwrap()),
                _ => {
                    eprintln!("Unknown command on line {}: {}", index + 1, command);
                    exit(1);
                }
            });
        } else {
            eprintln!("Could not read line");
            exit(1);
        }
    }
    // eprintln!("{:#?}", tree);

    let mut code_gen = String::new();
    for command in tree {
        code_gen += (String::new()
            + "    "
            + &(match command {
                DuckyCommand::Comment(s) => format!("// {}", s),
                DuckyCommand::Delay(ms) => format!("DigiKeyboard.delay({});", ms),
                DuckyCommand::String(s) => format!("DigiKeyboard.println(\"{}\");", s),
                DuckyCommand::Gui(c) => format!(
                    "DigiKeyboard.sendKeyStroke(KEY_{}, MOD_GUI_LEFT);",
                    c.to_uppercase()
                ),
                DuckyCommand::Modifier(cmd, k) => format!(
                    "DigiKeyboard.sendKeyStroke(KEY_{}, MOD_{}_LEFT);",
                    k.to_uppercase(),
                    cmd.to_uppercase()
                ),
                DuckyCommand::Menu => todo!(),
                DuckyCommand::DownArrow => format!("DigiKeyboard.sendKeyStroke(KEY_ARROW_DOWN);"),
                DuckyCommand::LeftArrow => format!("DigiKeyboard.sendKeyStroke(KEY_ARROW_LEFT);"),
                DuckyCommand::RightArrow => format!("DigiKeyboard.sendKeyStroke(KEY_ARROW_RIGHT);"),
                DuckyCommand::UpArrow => format!("DigiKeyboard.sendKeyStroke(KEY_ARROW_UP);"),
                DuckyCommand::Extended(s) => format!("DigiKeyboard.sendKeyStroke(KEY_{});", s),
                DuckyCommand::FunctionKey(f) => format!("DigiKeyboard.sendKeyStroke(KEY_F{});", f),
            })
            + "\n")
            .as_str();
    }

    let code = TEMPLATE.trim().replace("$CODE$", &code_gen.trim());
    writer.write(code.as_bytes()).unwrap();
}
